/*
 * Map Matching
 *
 * With the Map Matching service you can assign GPS positions to road segments on a digital map.
 *
 * The version of the OpenAPI document: 1.3
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using PTV.Developer.Clients.mapmatch.Client;
using PTV.Developer.Clients.mapmatch.Model;

namespace PTV.Developer.Clients.mapmatch.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPositionsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Matches a single unrelated position on a map.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.mapmatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="heading">The direction of travel defined by a clockwise angle with respect to north in degrees \\[°\\], e.g., 0° is north, 90° is east, 180° is south, and 270° is west. (optional)</param>
        /// <param name="calculationMode">The calculationMode affects the quality and performance of the matching. (optional)</param>
        /// <param name="results">Selects which properties the MatchedPosition will contain. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <returns>MatchedPosition</returns>
        MatchedPosition MatchPosition(double latitude, double longitude, double? heading = default(double?), CalculationMode? calculationMode = default(CalculationMode?), List<PositionsResultType> results = default(List<PositionsResultType>), string language = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Matches a single unrelated position on a map.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.mapmatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="heading">The direction of travel defined by a clockwise angle with respect to north in degrees \\[°\\], e.g., 0° is north, 90° is east, 180° is south, and 270° is west. (optional)</param>
        /// <param name="calculationMode">The calculationMode affects the quality and performance of the matching. (optional)</param>
        /// <param name="results">Selects which properties the MatchedPosition will contain. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <returns>ApiResponse of MatchedPosition</returns>
        ApiResponse<MatchedPosition> MatchPositionWithHttpInfo(double latitude, double longitude, double? heading = default(double?), CalculationMode? calculationMode = default(CalculationMode?), List<PositionsResultType> results = default(List<PositionsResultType>), string language = default(string));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPositionsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Matches a single unrelated position on a map.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.mapmatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="heading">The direction of travel defined by a clockwise angle with respect to north in degrees \\[°\\], e.g., 0° is north, 90° is east, 180° is south, and 270° is west. (optional)</param>
        /// <param name="calculationMode">The calculationMode affects the quality and performance of the matching. (optional)</param>
        /// <param name="results">Selects which properties the MatchedPosition will contain. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MatchedPosition</returns>
        System.Threading.Tasks.Task<MatchedPosition> MatchPositionAsync(double latitude, double longitude, double? heading = default(double?), CalculationMode? calculationMode = default(CalculationMode?), List<PositionsResultType> results = default(List<PositionsResultType>), string language = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Matches a single unrelated position on a map.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.mapmatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="heading">The direction of travel defined by a clockwise angle with respect to north in degrees \\[°\\], e.g., 0° is north, 90° is east, 180° is south, and 270° is west. (optional)</param>
        /// <param name="calculationMode">The calculationMode affects the quality and performance of the matching. (optional)</param>
        /// <param name="results">Selects which properties the MatchedPosition will contain. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MatchedPosition)</returns>
        System.Threading.Tasks.Task<ApiResponse<MatchedPosition>> MatchPositionWithHttpInfoAsync(double latitude, double longitude, double? heading = default(double?), CalculationMode? calculationMode = default(CalculationMode?), List<PositionsResultType> results = default(List<PositionsResultType>), string language = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPositionsApi : IPositionsApiSync, IPositionsApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class PositionsApi : IPositionsApi
    {
        private PTV.Developer.Clients.mapmatch.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="PositionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PositionsApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PositionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PositionsApi(string basePath)
        {
            this.Configuration = PTV.Developer.Clients.mapmatch.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.mapmatch.Client.GlobalConfiguration.Instance,
                new PTV.Developer.Clients.mapmatch.Client.Configuration { BasePath = basePath }
            );
            this.Client = new PTV.Developer.Clients.mapmatch.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.mapmatch.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = PTV.Developer.Clients.mapmatch.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PositionsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public PositionsApi(PTV.Developer.Clients.mapmatch.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = PTV.Developer.Clients.mapmatch.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.mapmatch.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new PTV.Developer.Clients.mapmatch.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.mapmatch.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = PTV.Developer.Clients.mapmatch.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PositionsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public PositionsApi(PTV.Developer.Clients.mapmatch.Client.ISynchronousClient client, PTV.Developer.Clients.mapmatch.Client.IAsynchronousClient asyncClient, PTV.Developer.Clients.mapmatch.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = PTV.Developer.Clients.mapmatch.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public PTV.Developer.Clients.mapmatch.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public PTV.Developer.Clients.mapmatch.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public PTV.Developer.Clients.mapmatch.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public PTV.Developer.Clients.mapmatch.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        ///  Matches a single unrelated position on a map.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.mapmatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="heading">The direction of travel defined by a clockwise angle with respect to north in degrees \\[°\\], e.g., 0° is north, 90° is east, 180° is south, and 270° is west. (optional)</param>
        /// <param name="calculationMode">The calculationMode affects the quality and performance of the matching. (optional)</param>
        /// <param name="results">Selects which properties the MatchedPosition will contain. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <returns>MatchedPosition</returns>
        public MatchedPosition MatchPosition(double latitude, double longitude, double? heading = default(double?), CalculationMode? calculationMode = default(CalculationMode?), List<PositionsResultType> results = default(List<PositionsResultType>), string language = default(string))
        {
            PTV.Developer.Clients.mapmatch.Client.ApiResponse<MatchedPosition> localVarResponse = MatchPositionWithHttpInfo(latitude, longitude, heading, calculationMode, results, language);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Matches a single unrelated position on a map.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.mapmatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="heading">The direction of travel defined by a clockwise angle with respect to north in degrees \\[°\\], e.g., 0° is north, 90° is east, 180° is south, and 270° is west. (optional)</param>
        /// <param name="calculationMode">The calculationMode affects the quality and performance of the matching. (optional)</param>
        /// <param name="results">Selects which properties the MatchedPosition will contain. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <returns>ApiResponse of MatchedPosition</returns>
        public PTV.Developer.Clients.mapmatch.Client.ApiResponse<MatchedPosition> MatchPositionWithHttpInfo(double latitude, double longitude, double? heading = default(double?), CalculationMode? calculationMode = default(CalculationMode?), List<PositionsResultType> results = default(List<PositionsResultType>), string language = default(string))
        {
            PTV.Developer.Clients.mapmatch.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.mapmatch.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.mapmatch.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.mapmatch.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("latitude", PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToString(latitude)); // path parameter
            localVarRequestOptions.PathParameters.Add("longitude", PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToString(longitude)); // path parameter
            if (heading != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToMultiMap("", "heading", heading));
            }
            if (calculationMode != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToMultiMap("", "calculationMode", calculationMode));
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<MatchedPosition>("/positions/{latitude}/{longitude}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("MatchPosition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Matches a single unrelated position on a map.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.mapmatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="heading">The direction of travel defined by a clockwise angle with respect to north in degrees \\[°\\], e.g., 0° is north, 90° is east, 180° is south, and 270° is west. (optional)</param>
        /// <param name="calculationMode">The calculationMode affects the quality and performance of the matching. (optional)</param>
        /// <param name="results">Selects which properties the MatchedPosition will contain. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MatchedPosition</returns>
        public async System.Threading.Tasks.Task<MatchedPosition> MatchPositionAsync(double latitude, double longitude, double? heading = default(double?), CalculationMode? calculationMode = default(CalculationMode?), List<PositionsResultType> results = default(List<PositionsResultType>), string language = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.mapmatch.Client.ApiResponse<MatchedPosition> localVarResponse = await MatchPositionWithHttpInfoAsync(latitude, longitude, heading, calculationMode, results, language, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Matches a single unrelated position on a map.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.mapmatch.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="heading">The direction of travel defined by a clockwise angle with respect to north in degrees \\[°\\], e.g., 0° is north, 90° is east, 180° is south, and 270° is west. (optional)</param>
        /// <param name="calculationMode">The calculationMode affects the quality and performance of the matching. (optional)</param>
        /// <param name="results">Selects which properties the MatchedPosition will contain. (optional)</param>
        /// <param name="language">The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MatchedPosition)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.mapmatch.Client.ApiResponse<MatchedPosition>> MatchPositionWithHttpInfoAsync(double latitude, double longitude, double? heading = default(double?), CalculationMode? calculationMode = default(CalculationMode?), List<PositionsResultType> results = default(List<PositionsResultType>), string language = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.mapmatch.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.mapmatch.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.mapmatch.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.mapmatch.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("latitude", PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToString(latitude)); // path parameter
            localVarRequestOptions.PathParameters.Add("longitude", PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToString(longitude)); // path parameter
            if (heading != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToMultiMap("", "heading", heading));
            }
            if (calculationMode != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToMultiMap("", "calculationMode", calculationMode));
            }
            if (results != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToMultiMap("csv", "results", results));
            }
            if (language != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.mapmatch.Client.ClientUtils.ParameterToMultiMap("", "language", language));
            }

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<MatchedPosition>("/positions/{latitude}/{longitude}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("MatchPosition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
