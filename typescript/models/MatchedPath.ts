/* tslint:disable */
/* eslint-disable */
/**
 * Map Matching
 * With the Map Matching service you can assign GPS positions to road segments on a digital map.
 *
 * The version of the OpenAPI document: 1.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
/**
 * Detailed information about a continuous part of a matched track.
 * @export
 * @interface MatchedPath
 */
export interface MatchedPath {
    /**
     * The distance [m] of the complete matched path.
     * @type {number}
     * @memberof MatchedPath
     */
    distance: number;
    /**
     * Start time of this path defined according to [RFC 3339](https://tools.ietf.org/html/rfc3339).
     * @type {Date}
     * @memberof MatchedPath
     */
    startTime?: Date;
    /**
     * The index in the list of trackPositions of the start position of this path. It is available only if the list of trackPositions is requested by MatchedTrackResults.TRACK_POSITIONS.
     * @type {number}
     * @memberof MatchedPath
     */
    startTrackPositionIndex?: number;
    /**
     * End time of this path defined according to [RFC 3339](https://tools.ietf.org/html/rfc3339).
     * @type {Date}
     * @memberof MatchedPath
     */
    endTime?: Date;
    /**
     * The index in the list of trackPositions of the end position of this path. It is available only if the list of trackPositions is requested by MatchedTrackResults.TRACK_POSITIONS.
     * @type {number}
     * @memberof MatchedPath
     */
    endTrackPositionIndex?: number;
    /**
     * The ID of the route for this path. It is available only if it is requested by MatchedTrackResults.ROUTE_ID. This route ID can be used as an input parameter in a calculateRoute request at the Routing API and is valid for 12 hours.
     * @type {string}
     * @memberof MatchedPath
     */
    routeId?: string;
}

/**
 * Check if a given object implements the MatchedPath interface.
 */
export function instanceOfMatchedPath(value: object): value is MatchedPath {
    if (!('distance' in value) || value['distance'] === undefined) return false;
    return true;
}

export function MatchedPathFromJSON(json: any): MatchedPath {
    return MatchedPathFromJSONTyped(json, false);
}

export function MatchedPathFromJSONTyped(json: any, ignoreDiscriminator: boolean): MatchedPath {
    if (json == null) {
        return json;
    }
    return {
        
        'distance': json['distance'],
        'startTime': json['startTime'] == null ? undefined : (new Date(json['startTime'])),
        'startTrackPositionIndex': json['startTrackPositionIndex'] == null ? undefined : json['startTrackPositionIndex'],
        'endTime': json['endTime'] == null ? undefined : (new Date(json['endTime'])),
        'endTrackPositionIndex': json['endTrackPositionIndex'] == null ? undefined : json['endTrackPositionIndex'],
        'routeId': json['routeId'] == null ? undefined : json['routeId'],
    };
}

export function MatchedPathToJSON(value?: MatchedPath | null): any {
    if (value == null) {
        return value;
    }
    return {
        
        'distance': value['distance'],
        'startTime': value['startTime'] == null ? undefined : ((value['startTime']).toISOString()),
        'startTrackPositionIndex': value['startTrackPositionIndex'],
        'endTime': value['endTime'] == null ? undefined : ((value['endTime']).toISOString()),
        'endTrackPositionIndex': value['endTrackPositionIndex'],
        'routeId': value['routeId'],
    };
}

