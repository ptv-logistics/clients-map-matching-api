/*
 * Map Matching
 * With the Map Matching service you can assign GPS positions to road segments on a digital map.
 *
 * The version of the OpenAPI document: 1.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.ptvgroup.developer.client.mapmatch.api;

import com.ptvgroup.developer.client.mapmatch.ApiClient;
import com.ptvgroup.developer.client.mapmatch.ApiException;
import com.ptvgroup.developer.client.mapmatch.ApiResponse;
import com.ptvgroup.developer.client.mapmatch.Pair;

import com.ptvgroup.developer.client.mapmatch.model.CalculationMode;
import com.ptvgroup.developer.client.mapmatch.model.ErrorResponse;
import com.ptvgroup.developer.client.mapmatch.model.MatchedPosition;
import com.ptvgroup.developer.client.mapmatch.model.PositionsResultType;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T11:58:08.355728377Z[Etc/UTC]", comments = "Generator version: 7.8.0")
public class PositionsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public PositionsApi() {
    this(new ApiClient());
  }

  public PositionsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * 
   * Matches a single unrelated position on a map.
   * @param latitude  (required)
   * @param longitude  (required)
   * @param heading The direction of travel defined by a clockwise angle with respect to north in degrees \\[°\\], e.g., 0° is north, 90° is east, 180° is south, and 270° is west. (optional)
   * @param calculationMode The calculationMode affects the quality and performance of the matching. (optional, default to STANDARD)
   * @param results Selects which properties the MatchedPosition will contain. (optional)
   * @param language The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)
   * @return MatchedPosition
   * @throws ApiException if fails to make API call
   */
  public MatchedPosition matchPosition(Double latitude, Double longitude, Double heading, CalculationMode calculationMode, List<PositionsResultType> results, String language) throws ApiException {
    ApiResponse<MatchedPosition> localVarResponse = matchPositionWithHttpInfo(latitude, longitude, heading, calculationMode, results, language);
    return localVarResponse.getData();
  }

  /**
   * 
   * Matches a single unrelated position on a map.
   * @param latitude  (required)
   * @param longitude  (required)
   * @param heading The direction of travel defined by a clockwise angle with respect to north in degrees \\[°\\], e.g., 0° is north, 90° is east, 180° is south, and 270° is west. (optional)
   * @param calculationMode The calculationMode affects the quality and performance of the matching. (optional, default to STANDARD)
   * @param results Selects which properties the MatchedPosition will contain. (optional)
   * @param language The preferred language for the response formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. By default the service uses the language spoken in the country or region of the result. In case the given preferred language is not available in the data, the default language is used. (optional)
   * @return ApiResponse&lt;MatchedPosition&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<MatchedPosition> matchPositionWithHttpInfo(Double latitude, Double longitude, Double heading, CalculationMode calculationMode, List<PositionsResultType> results, String language) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = matchPositionRequestBuilder(latitude, longitude, heading, calculationMode, results, language);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("matchPosition", localVarResponse);
        }
        return new ApiResponse<MatchedPosition>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<MatchedPosition>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder matchPositionRequestBuilder(Double latitude, Double longitude, Double heading, CalculationMode calculationMode, List<PositionsResultType> results, String language) throws ApiException {
    // verify the required parameter 'latitude' is set
    if (latitude == null) {
      throw new ApiException(400, "Missing the required parameter 'latitude' when calling matchPosition");
    }
    // verify the required parameter 'longitude' is set
    if (longitude == null) {
      throw new ApiException(400, "Missing the required parameter 'longitude' when calling matchPosition");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/positions/{latitude}/{longitude}"
        .replace("{latitude}", ApiClient.urlEncode(latitude.toString()))
        .replace("{longitude}", ApiClient.urlEncode(longitude.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "heading";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("heading", heading));
    localVarQueryParameterBaseName = "calculationMode";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("calculationMode", calculationMode));
    localVarQueryParameterBaseName = "results";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "results", results));
    localVarQueryParameterBaseName = "language";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("language", language));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
