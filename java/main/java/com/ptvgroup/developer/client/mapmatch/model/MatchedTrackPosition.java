/*
 * Map Matching
 * With the Map Matching service you can assign GPS positions to road segments on a digital map.
 *
 * The version of the OpenAPI document: 1.7
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ptvgroup.developer.client.mapmatch.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.ptvgroup.developer.client.mapmatch.model.MatchType;
import com.ptvgroup.developer.client.mapmatch.model.SegmentAttributes;
import java.time.OffsetDateTime;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import com.ptvgroup.developer.client.mapmatch.ApiClient;
/**
 * Detailed information about a position on a track matched on a map.
 */
@JsonPropertyOrder({
  MatchedTrackPosition.JSON_PROPERTY_MATCH_TYPE,
  MatchedTrackPosition.JSON_PROPERTY_TIMESTAMP,
  MatchedTrackPosition.JSON_PROPERTY_DISTANCE_FROM_PREVIOUS_MATCH,
  MatchedTrackPosition.JSON_PROPERTY_LATITUDE,
  MatchedTrackPosition.JSON_PROPERTY_LONGITUDE,
  MatchedTrackPosition.JSON_PROPERTY_SEGMENT_GEOMETRY,
  MatchedTrackPosition.JSON_PROPERTY_MATCH_DISTANCE,
  MatchedTrackPosition.JSON_PROPERTY_ANGLE_DIFFERENCE,
  MatchedTrackPosition.JSON_PROPERTY_SEGMENT_ATTRIBUTES
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-11-28T08:43:50.512271014Z[Etc/UTC]", comments = "Generator version: 7.8.0")
public class MatchedTrackPosition {
  public static final String JSON_PROPERTY_MATCH_TYPE = "matchType";
  private MatchType matchType;

  public static final String JSON_PROPERTY_TIMESTAMP = "timestamp";
  private OffsetDateTime timestamp;

  public static final String JSON_PROPERTY_DISTANCE_FROM_PREVIOUS_MATCH = "distanceFromPreviousMatch";
  private Integer distanceFromPreviousMatch;

  public static final String JSON_PROPERTY_LATITUDE = "latitude";
  private Double latitude;

  public static final String JSON_PROPERTY_LONGITUDE = "longitude";
  private Double longitude;

  public static final String JSON_PROPERTY_SEGMENT_GEOMETRY = "segmentGeometry";
  private String segmentGeometry;

  public static final String JSON_PROPERTY_MATCH_DISTANCE = "matchDistance";
  private Integer matchDistance;

  public static final String JSON_PROPERTY_ANGLE_DIFFERENCE = "angleDifference";
  private Double angleDifference;

  public static final String JSON_PROPERTY_SEGMENT_ATTRIBUTES = "segmentAttributes";
  private SegmentAttributes segmentAttributes;

  public MatchedTrackPosition() { 
  }

  public MatchedTrackPosition matchType(MatchType matchType) {
    this.matchType = matchType;
    return this;
  }

  /**
   * Get matchType
   * @return matchType
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_MATCH_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public MatchType getMatchType() {
    return matchType;
  }


  @JsonProperty(JSON_PROPERTY_MATCH_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMatchType(MatchType matchType) {
    this.matchType = matchType;
  }


  public MatchedTrackPosition timestamp(OffsetDateTime timestamp) {
    this.timestamp = timestamp;
    return this;
  }

  /**
   * Time defined according to [RFC 3339](https://tools.ietf.org/html/rfc3339) when the position was passed.
   * @return timestamp
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TIMESTAMP)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public OffsetDateTime getTimestamp() {
    return timestamp;
  }


  @JsonProperty(JSON_PROPERTY_TIMESTAMP)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTimestamp(OffsetDateTime timestamp) {
    this.timestamp = timestamp;
  }


  public MatchedTrackPosition distanceFromPreviousMatch(Integer distanceFromPreviousMatch) {
    this.distanceFromPreviousMatch = distanceFromPreviousMatch;
    return this;
  }

  /**
   * The travel distance [m] from the previous position. It is available only if MatchedTrackPosition.matchType is MATCH\\_SUCCESSFUL.
   * minimum: 0
   * @return distanceFromPreviousMatch
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DISTANCE_FROM_PREVIOUS_MATCH)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Integer getDistanceFromPreviousMatch() {
    return distanceFromPreviousMatch;
  }


  @JsonProperty(JSON_PROPERTY_DISTANCE_FROM_PREVIOUS_MATCH)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDistanceFromPreviousMatch(Integer distanceFromPreviousMatch) {
    this.distanceFromPreviousMatch = distanceFromPreviousMatch;
  }


  public MatchedTrackPosition latitude(Double latitude) {
    this.latitude = latitude;
    return this;
  }

  /**
   * The latitude value in degrees (WGS84/EPSG:4326) from south to north. This refers to the coordinates on the segment to which the input position matches. It is available only if MatchedTrackPosition.matchType is MATCH\\_SUCCESSFUL.
   * minimum: -90
   * maximum: 90
   * @return latitude
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LATITUDE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Double getLatitude() {
    return latitude;
  }


  @JsonProperty(JSON_PROPERTY_LATITUDE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLatitude(Double latitude) {
    this.latitude = latitude;
  }


  public MatchedTrackPosition longitude(Double longitude) {
    this.longitude = longitude;
    return this;
  }

  /**
   * The longitude value in degrees (WGS84/EPSG:4326) from west to east. This refers to the coordinates on the segment to which the input position matches. It is available only if MatchedTrackPosition.matchType is MATCH\\_SUCCESSFUL.
   * minimum: -180
   * maximum: 180
   * @return longitude
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LONGITUDE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Double getLongitude() {
    return longitude;
  }


  @JsonProperty(JSON_PROPERTY_LONGITUDE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLongitude(Double longitude) {
    this.longitude = longitude;
  }


  public MatchedTrackPosition segmentGeometry(String segmentGeometry) {
    this.segmentGeometry = segmentGeometry;
    return this;
  }

  /**
   * The geometry of the matched segment as a GeoJSON representation. Coordinates are always present in WGS84 (EPSG:4326). It is available only if MatchedTrackPosition.matchType is MATCH\\_SUCCESSFUL.
   * @return segmentGeometry
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SEGMENT_GEOMETRY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getSegmentGeometry() {
    return segmentGeometry;
  }


  @JsonProperty(JSON_PROPERTY_SEGMENT_GEOMETRY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSegmentGeometry(String segmentGeometry) {
    this.segmentGeometry = segmentGeometry;
  }


  public MatchedTrackPosition matchDistance(Integer matchDistance) {
    this.matchDistance = matchDistance;
    return this;
  }

  /**
   * The straight-line distance (Euclidean distance) [m] from the input position to the matching segment. It is available only if MatchedTrackPosition.matchType is MATCH\\_SUCCESSFUL.
   * minimum: 0
   * @return matchDistance
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_MATCH_DISTANCE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Integer getMatchDistance() {
    return matchDistance;
  }


  @JsonProperty(JSON_PROPERTY_MATCH_DISTANCE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMatchDistance(Integer matchDistance) {
    this.matchDistance = matchDistance;
  }


  public MatchedTrackPosition angleDifference(Double angleDifference) {
    this.angleDifference = angleDifference;
    return this;
  }

  /**
   * The difference in degrees \\[Â°\\] between the angle of the heading of the input position and the angle of the matching segment. This difference is always smaller than the straight angle.  It is available only if MatchedTrackPosition.matchType is MATCH\\_SUCCESSFUL.
   * minimum: 0
   * maximum: 180
   * @return angleDifference
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ANGLE_DIFFERENCE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Double getAngleDifference() {
    return angleDifference;
  }


  @JsonProperty(JSON_PROPERTY_ANGLE_DIFFERENCE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAngleDifference(Double angleDifference) {
    this.angleDifference = angleDifference;
  }


  public MatchedTrackPosition segmentAttributes(SegmentAttributes segmentAttributes) {
    this.segmentAttributes = segmentAttributes;
    return this;
  }

  /**
   * Get segmentAttributes
   * @return segmentAttributes
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SEGMENT_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public SegmentAttributes getSegmentAttributes() {
    return segmentAttributes;
  }


  @JsonProperty(JSON_PROPERTY_SEGMENT_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSegmentAttributes(SegmentAttributes segmentAttributes) {
    this.segmentAttributes = segmentAttributes;
  }


  /**
   * Return true if this MatchedTrackPosition object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MatchedTrackPosition matchedTrackPosition = (MatchedTrackPosition) o;
    return Objects.equals(this.matchType, matchedTrackPosition.matchType) &&
        Objects.equals(this.timestamp, matchedTrackPosition.timestamp) &&
        Objects.equals(this.distanceFromPreviousMatch, matchedTrackPosition.distanceFromPreviousMatch) &&
        Objects.equals(this.latitude, matchedTrackPosition.latitude) &&
        Objects.equals(this.longitude, matchedTrackPosition.longitude) &&
        Objects.equals(this.segmentGeometry, matchedTrackPosition.segmentGeometry) &&
        Objects.equals(this.matchDistance, matchedTrackPosition.matchDistance) &&
        Objects.equals(this.angleDifference, matchedTrackPosition.angleDifference) &&
        Objects.equals(this.segmentAttributes, matchedTrackPosition.segmentAttributes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(matchType, timestamp, distanceFromPreviousMatch, latitude, longitude, segmentGeometry, matchDistance, angleDifference, segmentAttributes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MatchedTrackPosition {\n");
    sb.append("    matchType: ").append(toIndentedString(matchType)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    distanceFromPreviousMatch: ").append(toIndentedString(distanceFromPreviousMatch)).append("\n");
    sb.append("    latitude: ").append(toIndentedString(latitude)).append("\n");
    sb.append("    longitude: ").append(toIndentedString(longitude)).append("\n");
    sb.append("    segmentGeometry: ").append(toIndentedString(segmentGeometry)).append("\n");
    sb.append("    matchDistance: ").append(toIndentedString(matchDistance)).append("\n");
    sb.append("    angleDifference: ").append(toIndentedString(angleDifference)).append("\n");
    sb.append("    segmentAttributes: ").append(toIndentedString(segmentAttributes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `matchType` to the URL query string
    if (getMatchType() != null) {
      joiner.add(String.format("%smatchType%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getMatchType()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `timestamp` to the URL query string
    if (getTimestamp() != null) {
      joiner.add(String.format("%stimestamp%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getTimestamp()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `distanceFromPreviousMatch` to the URL query string
    if (getDistanceFromPreviousMatch() != null) {
      joiner.add(String.format("%sdistanceFromPreviousMatch%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getDistanceFromPreviousMatch()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `latitude` to the URL query string
    if (getLatitude() != null) {
      joiner.add(String.format("%slatitude%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getLatitude()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `longitude` to the URL query string
    if (getLongitude() != null) {
      joiner.add(String.format("%slongitude%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getLongitude()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `segmentGeometry` to the URL query string
    if (getSegmentGeometry() != null) {
      joiner.add(String.format("%ssegmentGeometry%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getSegmentGeometry()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `matchDistance` to the URL query string
    if (getMatchDistance() != null) {
      joiner.add(String.format("%smatchDistance%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getMatchDistance()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `angleDifference` to the URL query string
    if (getAngleDifference() != null) {
      joiner.add(String.format("%sangleDifference%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getAngleDifference()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `segmentAttributes` to the URL query string
    if (getSegmentAttributes() != null) {
      joiner.add(getSegmentAttributes().toUrlQueryString(prefix + "segmentAttributes" + suffix));
    }

    return joiner.toString();
  }
}

